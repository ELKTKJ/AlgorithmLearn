# Chapter02 数组

## 2.1 数组的基础知识

数组是是由**相同类型**的元素组成的数据集合，并且占据一块**连续**的内存并按照**顺序**存储数据。

创建数组时需要先指定数组的容量大小，然后根据容量大小分配内存。即使只在数组中存储一个数字，也需要为所有的数据预先分配内存。因此，数组的空间效率不一定很高，可能会有**空闲区域**没有得到充分利用。

为了解决数组空间效率不高的问题，又设计实现了**动态数组**，如`Java`中的`ArrayList`。动态数组既保留了数组时间效率高的特性，又能够在数组中不断添加新的元素。为了避免浪费，可以先为数组分配较小的内存空间，然后在需要的时候在数组中添加新的数据。当数据的数目增加导致数组的容量不足时，需要重新分配一块更大的空间(通常新的容量是之前容量的2倍)，把之前的数据复制到新的数组中，再把之前的内存释放。这样能减少内存的浪费，但每次扩充数组容量时都有大量的额外操作，这对时间性能有负面影响。

## 2.2 双指针

双指针是一种常用的解题思路，可以使用两个**相反方向**或**相同方向**的指针扫描数组从而达到解题目的。此处的指针是指能定位数据容器中某个数据的手段。在数组中它实际上是数字的**下标**。

1. **方向相反**的双指针经常用来求**排序数组**中的两个数字之和。一个指针`P1`指向数组的第`1`个数字，另一个指针`P2`指向数组的最后一个数字，然后比较两个指针指向的数字之和及一个目标值。如果两个指针指向的数字之和**大于**目标值，则向**左**移动指针`P2`；如果两个指针指向的数字之和**小于**目标值，则向**右**移动指针`P1`。此时两个指针的移动方向是相反的。

2. **方向相同**的双指针通常用来求正数数组中子数组的和或乘积。初始化的时候两个指针`P1`和`P2`都指向数组的第`1`个数字。如果两个指针之间的子数组的和或乘积大于目标值，则向右移动指针`P1`删除子数组最左边的数字；如果两个指针之间的子数组的和或乘积小于目标值，则向右移动指针`P2`在子数组的右边增加新的数字。此时两个指针的移动方向是相同的。

### 面试题6：排序数组中的两个数字之和

```plain
题目：输入一个递增排序的数组和一个值k，请问如何在数组中找出两个和为k的数字并返回它们的下标？假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。例如，输入数组[1，2，4，6，10]，k的值为8，数组中的数字2与6的和为8，它们的下标分别为1与3。
```

1. 暴力法就是先在数组中固定一个数字，再依次判断数组中其余的数字与它的和是不是等于`k`。如果数组的长度是`n`，由于需要对每个数字和其他`n-1`个数字求和，因此这种解法的时间复杂度是$O(n^2)$。

- 二分优化。假设扫描到数字`i`，如果数组中存在另一个数字`k-i`，那么就找到了一对和为`k`的数字。没有必要通过从头到尾逐个扫描数组中的每个数字来判断数组中是否存在`k-i`。由于数组是**递增**排序的，因此可以用二分查找在数组中搜索`k-i`。二分查找的时间复杂度是$O(logn)$，因此优化之后的解法的时间复杂度是$O(nlogn)$

- 用**空间换时间**进行优化。先将数组中的所有数字都放入一个哈希表，然后逐一扫描数组中的每个数字。假设扫描到数字`i`，如果哈希表中存在另一个数字`k-i`，那么就找到了一对和为`k`的数字。判断哈希表中是否存在一个数字的时间复杂度是$O(1)$，因此新解法的时间复杂度是$O(n)$，同时它需要一个大小为$O(n)$的哈希表，空间复杂度也是O(n)。

上述的几种方法都不是理论上的最优解，因为都没有充分利用数组是一个排序数组的条件。

用两个指针`P1`和`P2`分别指向数组中的两个数字。指针`P1`初始化指向数组的第`1`个(下标为0)数字，指针`P2`初始化指向数组的最后一个数字。如果指针`P1`和`P2`指向的两个数字之和等于输入的`k`，那么就找到了符合条件的两个数字。如果指针`P1`和`P2`指向的两个数字之和小于`k`，那么我们希望两个数字的和再大一点。由于数组已经排好序，因此可以考虑把指针`P1`向右移动。因为在排序数组中右边的数字要大一些，所以两个数字的和也要大一些，这样就有可能等于输入的数字`k`。同样，当两个数字的和大于输入的数字`k`时，可以把指针`P2`向左移动，因为在排序数组中左边的数字要小一些。

时间复杂度是$O(n)$、空间复杂度是$O(1)$

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int l = 0, r = numbers.length - 1;
        while(l < r) {
            int sum = numbers[l] + numbers[r];
            if(sum == target) {
                return new int[]{l, r};
            } else if(sum > target) {
                r--;
            } else {
                l++;
            }
        }
        return new int[0];
    }
}
```

另一种代码，单出口：

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int l = 0, r = numbers.length - 1;
        while(l < r && numbers[l] + numbers[r] != target) {
            if(numbers[l] + numbers[r] > target) {
                r--;
            } else {
                l++;
            }
        }
        return new int[]{l, r};
    }
}
```

上述代码中只有一个while循环，循环执行的次数最多等于数组的长度，因此这种思路的时间复杂度是$O(n)$。

### 面试题7：数组中和为0的3个数字

```java
题目：输入一个数组，如何找出数组中所有和为0的3个数字的三元组？需要注意的是，返回值中不得包含重复的三元组。例如，在数组[-1，0，1，2，-1，-4]中有两个三元组的和为0，它们分别是[-1，0，1]和[-1，-1，2]。
```

这个题目是面试题6的加强版。如果输入的数组是**排序**的，就可以先固定一个数字`i`，然后在排序数组中查找和为`-i`的两个数字。我们已经有了用$O(n)$时间在**排序数组**中找出**和为给定值**的两个数字的方法，由于需要固定数组中的每个数字，因此查找三元组的时间复杂度是$O(n^2)$。

需要先对数组排序。排序算法的时间复杂度通常是$O(nlogn)$，因此这种解法的总的时间复杂度是$O(nlogn)+O(n^2)$，仍然是$O(n2)$。

如何去除重复的三元组。前面提到需要使用两个指针来找出和为给定值的两个数字。在找到一个和为0的三元组之后，就需要移动这两个指针，以便找出其他符合条件的三元组。在移动指针的时候需要**跳过所有相同的值**，以便过滤掉重复的三元组。

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if(nums.length >= 3) {
            Arrays.sort(nums);
            int i = 0;
            while(i < nums.length - 2) {
                twoSum(nums, i, res);
                int t = nums[i];
                while(i < nums.length && nums[i] == t) {
                    i++;
                }
            }
        }
        return res;
    }

    private void twoSum(int[] nums, int i, List<List<Integer>> res) {
        int j = i + 1;
        int k = nums.length - 1;
        while(j < k) {
            int sum = nums[i] + nums[j] + nums[k];
            if(sum == 0) {
                res.add(Arrays.asList(nums[i], nums[j], nums[k]));

                int t = nums[j];
                while(j < k && nums[j] == t) {
                    j++;
                }
            } else if(sum > 0) {
                k--;
            } else {
                j++;
            }
        }
    }
}
```

上述代码先对数组进行**排序**。在固定用变量`i`指向的数字之后，函数`twoSum`在排序后的数组中找出所有下标大于`i`并且和为`-nums[i]`的两个数字(下标分别为`j`和`k`)。如果`nums[i]`、`nums[j]`、`nums[k]`的和大于`0`，那么下标`k`向左移动；如果`nums[i]`、`nums[j]`、`nums[k]`的和小于`0`，那么下标`j`向右移动。如果3个数字之和正好等于0，那么向右移动下标`j`，以便找到其他和为`-nums[i]`的两个数字。

由于要避免重复的三元组，因此函数twoSum使用一个while循环让下标`j`跳过重复的数字。基于同样的原因，函数`threeSum`中也有一个`while`循环让下标`i`跳过重复的数字。

> `i`和`j`都需要跳过相同的数字避免重复。

## 2.3 累加数组数字求子数组之和

## 2.4 本章小结