# Chapter02 数组

## 2.1 数组的基础知识

数组是是由**相同类型**的元素组成的数据集合，并且占据一块**连续**的内存并按照**顺序**存储数据。

创建数组时需要先指定数组的容量大小，然后根据容量大小分配内存。即使只在数组中存储一个数字，也需要为所有的数据预先分配内存。因此，数组的空间效率不一定很高，可能会有**空闲区域**没有得到充分利用。

为了解决数组空间效率不高的问题，又设计实现了**动态数组**，如`Java`中的`ArrayList`。动态数组既保留了数组时间效率高的特性，又能够在数组中不断添加新的元素。为了避免浪费，可以先为数组分配较小的内存空间，然后在需要的时候在数组中添加新的数据。当数据的数目增加导致数组的容量不足时，需要重新分配一块更大的空间(通常新的容量是之前容量的2倍)，把之前的数据复制到新的数组中，再把之前的内存释放。这样能减少内存的浪费，但每次扩充数组容量时都有大量的额外操作，这对时间性能有负面影响。

## 2.2 双指针

双指针是一种常用的解题思路，可以使用两个**相反方向**或**相同方向**的指针扫描数组从而达到解题目的。此处的指针是指能定位数据容器中某个数据的手段。在数组中它实际上是数字的**下标**。

1. **方向相反**的双指针经常用来求**排序数组**中的两个数字之和。一个指针`P1`指向数组的第`1`个数字，另一个指针`P2`指向数组的最后一个数字，然后比较两个指针指向的数字之和及一个目标值。如果两个指针指向的数字之和**大于**目标值，则向**左**移动指针`P2`；如果两个指针指向的数字之和**小于**目标值，则向**右**移动指针`P1`。此时两个指针的移动方向是相反的。

2. **方向相同**的双指针通常用来求正数数组中子数组的和或乘积。初始化的时候两个指针`P1`和`P2`都指向数组的第`1`个数字。如果两个指针之间的子数组的和或乘积大于目标值，则向右移动指针`P1`删除子数组最左边的数字；如果两个指针之间的子数组的和或乘积小于目标值，则向右移动指针`P2`在子数组的右边增加新的数字。此时两个指针的移动方向是相同的。

### 面试题6：排序数组中的两个数字之和

```plain
题目：输入一个递增排序的数组和一个值k，请问如何在数组中找出两个和为k的数字并返回它们的下标？假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。例如，输入数组[1，2，4，6，10]，k的值为8，数组中的数字2与6的和为8，它们的下标分别为1与3。
```

1. 暴力法就是先在数组中固定一个数字，再依次判断数组中其余的数字与它的和是不是等于`k`。如果数组的长度是`n`，由于需要对每个数字和其他`n-1`个数字求和，因此这种解法的时间复杂度是$O(n^2)$。

- 二分优化。假设扫描到数字`i`，如果数组中存在另一个数字`k-i`，那么就找到了一对和为`k`的数字。没有必要通过从头到尾逐个扫描数组中的每个数字来判断数组中是否存在`k-i`。由于数组是**递增**排序的，因此可以用二分查找在数组中搜索`k-i`。二分查找的时间复杂度是$O(logn)$，因此优化之后的解法的时间复杂度是$O(nlogn)$

- 用**空间换时间**进行优化。先将数组中的所有数字都放入一个哈希表，然后逐一扫描数组中的每个数字。假设扫描到数字`i`，如果哈希表中存在另一个数字`k-i`，那么就找到了一对和为`k`的数字。判断哈希表中是否存在一个数字的时间复杂度是$O(1)$，因此新解法的时间复杂度是$O(n)$，同时它需要一个大小为$O(n)$的哈希表，空间复杂度也是O(n)。

- 可以用类似于两数之和的思路。边遍历边往哈希表中添加元素。

上述的几种方法都不是理论上的最优解，因为都没有充分利用数组是一个排序数组的条件。

用两个指针`P1`和`P2`分别指向数组中的两个数字。指针`P1`初始化指向数组的第`1`个(下标为0)数字，指针`P2`初始化指向数组的最后一个数字。如果指针`P1`和`P2`指向的两个数字之和等于输入的`k`，那么就找到了符合条件的两个数字。如果指针`P1`和`P2`指向的两个数字之和小于`k`，那么我们希望两个数字的和再大一点。由于数组已经排好序，因此可以考虑把指针`P1`向右移动。因为在排序数组中右边的数字要大一些，所以两个数字的和也要大一些，这样就有可能等于输入的数字`k`。同样，当两个数字的和大于输入的数字`k`时，可以把指针`P2`向左移动，因为在排序数组中左边的数字要小一些。

时间复杂度是$O(n)$、空间复杂度是$O(1)$

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int l = 0, r = numbers.length - 1;
        while(l < r) {
            int sum = numbers[l] + numbers[r];
            if(sum == target) {
                return new int[]{l, r};
            } else if(sum > target) {
                r--;
            } else {
                l++;
            }
        }
        return new int[0];
    }
}
```

另一种代码，单出口：

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int l = 0, r = numbers.length - 1;
        while(l < r && numbers[l] + numbers[r] != target) {
            if(numbers[l] + numbers[r] > target) {
                r--;
            } else {
                l++;
            }
        }
        return new int[]{l, r};
    }
}
```

上述代码中只有一个while循环，循环执行的次数最多等于数组的长度，因此这种思路的时间复杂度是$O(n)$。

### 面试题7：数组中和为0的3个数字

```java
题目：输入一个数组，如何找出数组中所有和为0的3个数字的三元组？需要注意的是，返回值中不得包含重复的三元组。例如，在数组[-1，0，1，2，-1，-4]中有两个三元组的和为0，它们分别是[-1，0，1]和[-1，-1，2]。
```

这个题目是面试题6的加强版。如果输入的数组是**排序**的，就可以先固定一个数字`i`，然后在排序数组中查找和为`-i`的两个数字。我们已经有了用$O(n)$时间在**排序数组**中找出**和为给定值**的两个数字的方法，由于需要固定数组中的每个数字，因此查找三元组的时间复杂度是$O(n^2)$。

需要先对数组排序。排序算法的时间复杂度通常是$O(nlogn)$，因此这种解法的总的时间复杂度是$O(nlogn)+O(n^2)$，仍然是$O(n^2)$。

如何去除重复的三元组。前面提到需要使用两个指针来找出和为给定值的两个数字。在找到一个和为0的三元组之后，就需要移动这两个指针，以便找出其他符合条件的三元组。在移动指针的时候需要**跳过所有相同的值**，以便过滤掉重复的三元组。

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if(nums.length >= 3) {
            Arrays.sort(nums);
            int i = 0;
            while(i < nums.length - 2) {
                twoSum(nums, i, res);
                int t = nums[i];
                while(i < nums.length && nums[i] == t) {
                    i++;
                }
            }
        }
        return res;
    }

    private void twoSum(int[] nums, int i, List<List<Integer>> res) {
        int j = i + 1;
        int k = nums.length - 1;
        while(j < k) {
            int sum = nums[i] + nums[j] + nums[k];
            if(sum == 0) {
                res.add(Arrays.asList(nums[i], nums[j], nums[k]));

                int t = nums[j];
                while(j < k && nums[j] == t) {
                    j++;
                }
            } else if(sum > 0) {
                k--;
            } else {
                j++;
            }
        }
    }
}
```

上述代码先对数组进行**排序**。在固定用变量`i`指向的数字之后，函数`twoSum`在排序后的数组中找出所有下标大于`i`并且和为`-nums[i]`的两个数字(下标分别为`j`和`k`)。如果`nums[i]`、`nums[j]`、`nums[k]`的和**大于`0`**，那么下标`k`向左移动；如果`nums[i]`、`nums[j]`、`nums[k]`的和**小于`0`**，那么下标`j`向右移动。如果3个数字之和正好等于0，那么向右移动下标`j`(跳过重复情况)，以便找到其他和为`-nums[i]`的两个数字。

由于要避免重复的三元组，因此函数twoSum使用一个while循环让下标`j`跳过重复的数字。基于同样的原因，函数`threeSum`中也有一个`while`循环让下标`i`跳过重复的数字。

> `i`和`j`都需要跳过相同的数字避免重复。

### 面试题8：和大于或等于k的最短子数组

```plain
题目：输入一个正整数组成的数组和一个正整数k，请问数组中和大于或等于k的连续子数组的最短长度是多少？如果不存在所有数字之和大于或等于k的子数组，则返回0。例如，输入数组[5，1，4，3]，k的值为7，和大于或等于7的最短连续子数组是[4，3]，因此输出它的长度2。
```

子数组由数组中一个或**连续**的多个数字组成。一个子数组可以用两个指针表示。如果第1个指针`P1`指向子数组的第1个数字，第2个指针`P2`指向子数组的最后一个数字，那么子数组就是由这两个指针之间的所有数字组成的。

指针`P1`和`P2`初始化的时候都指向数组的第1个元素。如果两个指针之间的子数组中所有数字之和大于或等于`k`，那么把指针`P1`向**右**移动。每向右移动指针`P1`一步，相当于从子数组的最左边**删除**一个数字，子数组的长度也减1。由于数组中的数字都是正整数，从子数组中删除一些数字就能减小子数组之和。由于目标是找出和大于或等于`k`的最短子数组，因此**一直向右移动**指针`P1`，直到子数组的和小于`k`为止。

如果两个指针之间的子数组中所有数字之和**小于**`k`，那么把指针`P2`向右移动。指针`P2`每向右移动一步就相当于在子数组的最右边**添加**一个新的数字，子数组的长度加1。由于数组中的所有数字都是正整数，因此在子数组中添加新的数字能得到更大的子数组之和。

思路小结：当指针`P1`和`P2`之间的子数组数字之和小于`k`时，向右移动指针`P2`，直到两个指针之间的子数组数字之和大于`k`，否则向右移动指针`P1`，直到两个指针之间的子数组数字之和小于`k`。

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int minLength = Integer.MAX_VALUE;
        int sum = 0;
        for(int right = 0; right < nums.length; right++) {
            sum += nums[right];
            while(left <= right && sum >= target) {
                minLength = Math.min(minLength, right - left + 1);
                sum -= nums[left++];
            }
        }
        return minLength == Integer.MAX_VALUE ? 0 : minLength;
    }
}
```

在上述代码中，变量`left`是子数组中第`1`个数字的下标，相当于指针`P1`，而变量`right`是子数组中最后一个数字的下标，相当于指针`P2`。变量`sum`是位于两个指针之间的子数组中的所有数字之和。

时间复杂度：假设数组的长度为`n`，尽管上述代码中有两个嵌套的循环，该解法的时间复杂度仍然是$O(n)$。这是因为在这两个循环中，变量`left`和`right`都是只增加不减少，变量`right`从`0`增加到`n-1`，变量`left`从`0`最多增加到`n-1`，因此总的执行次数是$O(n)$。

### 面试题9：乘积小于k的子数组

```plain
题目：输入一个由正整数组成的数组和一个正整数k，请问数组中有多少个数字乘积小于k的连续子数组？例如，输入数组[10，5，2，6]，k的值为100，有8个子数组的所有数字的乘积小于100，它们分别是[10]、[5]、[2]、[6]、[10，5]、[5，2]、[2，6]和[5，2，6]。
```

用指针`P1`和`P2`指向数组中的两个数字，两个指针之间的数字组成一个子数组。指针`P1`永远不会走到指针`P2`的右边。两个指针初始化都指向数组的第1个数字(下标为0的数字)。

如果两个指针之间的子数组中数字的乘积小于`k`，则向右移动指针`P2`。向右移动指针`P2`相当于在子数组中添加一个新的数字，由于数组中的数字都是正整数，因此子数组中数字的乘积就会变大。

如果两个指针之间的子数组中数字的乘积大于或等于`k`，则向右移动指针`P1`。向右移动指针`P1`相当于从子数组中删除最左边的数字，由于数组中的数字都是正整数，因此子数组中数字的乘积就会变小。

```java

```

在上述代码中，变量`left`是子数组中第1个数字的下标，相当于指针`P1`，而变量`right`是子数组中最后一个数字的下标，相当于指针`P2`。变量`product`是位于两个指针之间的子数组中的所有数字的乘积。时间复杂度为$O(n)$。

## 2.3 累加数组数字求子数组之和

前面使用双指针解决子数组之和的问题有一个前提条件，即数组中所有数字都是正数。如果数组中的数字有正数、负数和零，那么双指针的思路并不适用，因为当数组中有负数时在子数组中添加数字不一定能增加子数组之和，从子数组中删除数字也不一定能减少子数组之和。

另一种思路：**前缀和**。假设整个数组的长度为`n`，它的某个子数组的第1个数字的下标是`i`，最后一个数字的下标是`j`。为了计算子数组之和，需要先做预处理，计算从数组下标为0的数字开始到以每个数字为结尾的子数组之和。预处理只需要从头到尾扫描一次，就能求出从下标0开始到下标0结束的子数组之和S0，从下标0开始到下标1结束的子数组之和S1，直到求出从下标0开始到最后一个数字的子数组之和$S_{n-1}$,因此从下标为$i$开始到下标为$j$结束的子数组的和就是$S_j-S_{i-1}$。

### 面试题10：和为k的子数组

```plain
题目：输入一个整数数组和一个整数k，请问数组中有多少个数字之和等于k的连续子数组？例如，输入数组[1，1，1]，k的值为2，有2个连续子数组之和等于2。
```

注意这个题目中没有说数字一定是正整数，有可能为负数。

分析：这个题目看起来也可以利用双指针来解决。我们还是用指针P1和P2指向数组中的两个数字，两个指针之间的数字组成一个子数组。如果两个指针之间的子数组的数字之和大于或等于k就向右移动指针P1，如果子数组的数字之和小于k就向右移动指针P2。这个使用双指针的解法基于如下假设：向右移动指针P2相当于在子数组中添加一个新的数字，从而得到更大的子数组的数字之和。如果新添加的数字是正数，那么这个假设是成立的。但本题中的数组并没有说明是由正整数组成的，因此不能保证在子数组中添加新的数字就能得到和更大的子数组。同样，也不能保证删除子数组最左边的数字就能得到和更小的子数组。

暴力法：在一个长度为`n`的数组中有$O(n^2)$个子数组，如果求每个子数组的和需要$O(n)$的时间，那么总共需要$O(n^3)$的时间就能求出所有子数组的和。


## 2.4 本章小结