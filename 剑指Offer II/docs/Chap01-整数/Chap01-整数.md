# Chapter01 整数

## 1.1 整数基础知识

编程语言可能会提供占据不同内存空间的整数类型，每种类型能表示的整数的范围也不相同。Java中有四种不同的整数类型：
| 类型 | 位数 | 范围 |
|:-:|:-:|:-:|
| `byte` | 8位 | $-2^7 \sim 2^7$ |
| `short` | 16位 | $-2^{15} \sim 2^{15}$ |
| `int` | 32位 | $-2^{31} \sim 2^{31}$ |
| `long` | 64位 | $-2^{63} \sim 2^{63}$ |

Java中的整数类型都是 **有符号** 整数(最高位始终是符号位)，最高位为0是正数，最高位为1是负数。`C/C++` 支持 **无符号** 整数。无论最高位是 `0` 还是 `1`，都表示其为一个 **正数**。无符号的32位整数的范围是 $0～2^{32}-1$。

由于整数的范围限制，如果计算结果超出了范围就会产生**溢出**。产生溢出时运行不会出错，但结果可能会出乎意料。如果除数为0，那么整数的除法在运行时将报错。

### 面试题1：整数除法

```
题目：输入2个int型整数，它们进行除法计算并返回商，要求不得使用乘号'*'、除号'/'及求余符号'%'。当发生溢出时，返回最大的整数值。假设除数不为0。例如，输入15和2，输出15/2的结果，即7。
```

本题限制 **不能** 使用 **乘号** 和 **除号** 进行运算。一个直观的解法是基于 **减法** 实现 **除法**。例如，为了求得 $15/2$ 的商，可以不断地从 $15$ 里减去 $2$，当减去 $7$ 个 $2$ 之后余数是 $1$ ，此时不能再减去更多的 $2$，因此 $15/2$ 的商是 $7$ 。我们可以用一个循环实现这个过程。

但这个直观的解法存在一个问题。当 **被除数很大** 但 **除数很小** 时，减法操作执行的次数会很多。例如，求 $(2^{31}-1)/1$，减 $1$ 的操作将执行 $2^{31}-1$ 次，需要很长的时间。如果被除数是 $n$，那么这种解法的时间复杂度为 $O(n)$。我们需要对这种解法进行优化。

可以将上述解法稍做调整。当 **被除数大于除数** 时，继续比较判断被除数是否大于除数的 $2$ 倍，如果是，则继续判断被除数是否大于除数的 $4$ 倍、$8$ 倍等。如果被除数最多大于除数的 $2^k$ 倍，那么将被除数减去除数的 $2^k$ 倍，然后将剩余的被除数重复前面的步骤。由于每次将除数 **翻倍**，因此优化后的时间复杂度是 $O(logn)$。如果有负数则可以将它们先转换成 **正数**，计算正数的除法之后再根据需要调整商的正负号。例如，如果计算 $-15/2$，则可以先计算 $15/2$，得到的商是 $7$ 。由于被除数和除数中有一个负数，因此商应该是负数，于是商应该是$-7$ 。

将负数转换成正数存在一个小问题。对于 $32$ 位的整数而言，最小的整数是 $-2^{31}$，最大的整数是 $2^{31}-1$。因此，如果将 $-2^{31}$ 转换为 **正数** 则会导致 **溢出**。由于将任意正数转换为负数都不会溢出，因此可以先将正数都转换成负数，用前面优化之后的减法计算两个负数的除法，然后根据需要调整商的正负号。

最后讨论可能的溢出。由于是整数的除法并且除数不等于0，因此商的绝对值一定小于或等于被除数的绝对值。因此，int型整数的除法只有一种情况会导致溢出，即 $(-2^{31}) /(-1)$。这是因为最大的正数为 $2^{31}-1$，$2^{31}$ 超出了正数的范围。

```java
class Solution {
    public int divide(int dividend, int divisor) {
        // 特判 -2^{31} -1
        if(dividend == 0x80000000 && divisor == -1) {
            return Integer.MAX_VALUE;
        }

        // 将被除数和除数都变为负数
        // 负数的数量
        int negative = 2;
        if(dividend > 0) {
            negative--;
            dividend = -dividend;
        }
        if(divisor > 0) {
            negative--;
            divisor = -divisor;
        }
        int res = divideCore(dividend, divisor);
        // 被除数和除数中有一个负数时，商为负数
        return negative == 1 ? -res : res;
    }

    // 使用减法实现两个负数的除法
    private int divideCore(int dividend, int divisor) {
        int result = 0;
        while(dividend <= divisor) {
            int value = divisor;
            int quotient = 1;
            while(value >= 0xc0000000 && dividend <= value + value) {
                value += value;
                quotient += quotient;
            }
            // 结果加上最大可以上的商
            result += quotient;
            // 被除数减去最大因子
            dividend -= value;
        }
        return result;
    }
}
```

$0x80000000$ 为最小的 $int$ 型整数，即 $- 2 ^ {31}$，$0xc0000000$ 是 $-2^{30}$

## 1.2 二进制

整数在计算机中是以二进制的形式表示的。位运算是把数字用二进制形式表示之后，对每位上0或1的运算。位运算只有6种：非、与、或、异或、左移和右移。

非运算对整数的二进制按位取反，0取反得1，1取反得0。

$$
\sim 00001010 = 11110101
$$
$$
\sim 10001010 = 01110101
$$

| | | | | |
|:-:|:-:|:-:|:-:|:-:|
|与(&) |0 & 0 = 0 | 1 & 0 = 0| 0 & 1 = 0 | 1 & 1 = 1 |
|或(\|) | 0 \| 0 = 0 | 1 \| 0 = 1 | 0 \| 1 = 1 | 1 \| 1 = 1 |
|异或(^) | 0 ^ 0 = 0| 1 ^ 0 = 1 | 0 ^ 1 = 1 | 1 ^ 1 = 0 |

左移运算符 $$m << n$$ 表示把 $m$ 左移 $n$ 位。如果左移 $n$ 位，最左边的 $n$ 位数字将被丢弃，同时在最右边补上 $n$ 个 $0$。

$$
00001010 << 2 = 00101000
$$

$$
10001010 << 3 = 01010000
$$

右移运算符 $$m >> n$$表示把 $m$ 右移 $n$ 位。最右边的 $n$ 位将被丢弃。【正数补0，负数补1】
1. 如果数字是一个无符号数值，则用0填充最左边的 $n$ 位
2. 如果数字是一个有符号数值，则用数字的符号填充最左边的 $n$ 位。
即如果数字原来是一个正数，则右移之后在最左边补 $n$ 个 $0$，如果数字原来是一个负数，则右移之后再左边补 $n$ 个 $1$。

$$
00001010 >> 2 = 00000010
$$

$$
10001010 >> 3 = 11110001
$$

Java中提供的无符号右移 `>>>`，无论是对正数还是负数进行无符号右移操作，都将在最左边插入 $0$。

$$
00001010 >>> 2 = 00000010
$$

$$
10001010 >>> 3 = 00010001
$$

### 面试题2：二进制加法

```plain
题目：输入两个表示二进制的字符串，请计算它们的和，并以二进制字符串的形式输出。例如，输入的二进制字符串分别是"11"和"10"，则输出"101"。
```

本题中没有限制二进制字符串的长度。当二进制字符串比较长时，它表示的整数可能会超出 $int$ 型整数或 $long$ 型整数的范围，此时不能直接将其转换成整数。

因此，加法操作只能针对两个字符串进行。可以参照十进制加法来完成二进制加法。在进行十进制加法时，总是将两个数字的右端对齐，然后从它们的个位开始从右向左相加同一位置的两个数位，如果前一位有进位还要加上进位。

二进制加法也可以采用类似的方法，从字符串的右端出发向左做加法。与十进制不同的是，二进制是逢二进一，当两个数位加起来等于2时就会产生进位。

```java
class Solution {
    public String addBinary(String a, String b) {
        StringBuilder sb = new StringBuilder();
        int m = a.length() - 1;
        int n = b.length() - 1;
        int t = 0;
        while(m >= 0 || n >= 0 || t != 0) {
            int digitA = m >= 0 ? a.charAt(m--) - '0' : 0;
            int digitB = n >= 0 ? b.charAt(n--) - '0' : 0;
            t = digitA + digitB + t;
            sb.append(t % 2);
            t /= 2;
        }
        return sb.reverse().toString();
    }
}
```

上述代码中的加法是从字符串的 **右端** 开始的，最低位保存在 `result` 的最左边，而通常数字最左边保存的是 **最高位**，因此，函数 $addBinary$ 在返回之前要将 `result` 进行 **翻转**。

另一种等价写法：

```java
class Solution {
    public String addBinary(String a, String b) {
        StringBuilder sb = new StringBuilder();
        int m = a.length() - 1;
        int n = b.length() - 1;
        int t = 0;
        while(m >= 0 || n >= 0 || t != 0) {
            if(m >= 0) t += a.charAt(m--) - '0';
            if(n >= 0) t += b.charAt(n--) - '0';
            sb.append(t % 2);
            t /= 2;
        }
        return sb.reverse().toString();
    }
}
```

### 面试题3：前n个数字二进制形式中1的个数

```plain
题目：输入一个非负数n，请计算0到n之间每个数字的二进制形式中1的个数，并输出一个数组。例如，输入的n为4，由于0、1、2、3、4的二进制形式中1的个数分别为0、1、1、2、1，因此输出数组[0，1，1，2，1]。
```

思路1：简单计算每个整数的二进制形式中1的个数

计算整数 $i$ 的二进制形式中 $1$ 的个数：每次用 `i & (i-1)` 将整数 `i` 的最右边的 `1` 变成 `0`。整数 `i` 减去 `1` ，那么它最右边的 `1` 变成 `0` 。如果它的右边还有 `0`，则右边所有的 `0` 都变成 `1`，而其左边所有位都保持不变。下面对 `i` 和 `i-1` 进行位 **与** 运算，相当于将其 **最右边** 的 `1` 变成 `0` 。以二进制的 `1100` 为例，它减去 `1` 的结果是`1011`。`1100` 和 `1011` 的 **位与** 运算的结果正好是 `1000`。二进制的 `1100` 最右边的 `1` 变为 `0` ，结果刚好就是 `1000`。

```java
class Solution {
    public int[] countBits(int n) {
        int[] res = new int[n + 1];
        for(int i = 1; i <= n; i++) {
            int j = i;
            while(j != 0) {
                res[i]++;
                j &= (j - 1);
            }
        }
        return res;
    }
}
```

若一个整数有 $k$ 位，对应的二进制形式中可能有 $O(k)$ 个 1。`while` 循环代码中对每个整数都将执行 $O(k)$ 次，因此总的时间复杂度为 $O(nk)$


思路二：根据`i&(i-1)`计算i的二进制形式中1的个数

`i & (i - 1)` 将 `i` 的二进制形式中最右边的 `1` 变成 `0`，也即整数 `i` 的二进制形式中 `1` 的个数比 `i & (i - 1)` 的二进制形式中 `1` 的个数多 `1`。由于 `i & (i - 1)` **小于** `i`，因此其二进制表示中 `1` 的个数已经被计算出来并存储到数组中，直接获取并加 $1$ 即可。

```java
class Solution {
    public int[] countBits(int n) {
        int[] res = new int[n + 1];
        for(int i = 1; i <= n; i++) {
            res[i] = res[i & (i - 1)] + 1;
        }
        return res;
    }
}
```

思路三：根据 `i/2` 计算 `i` 的二进制形式中 `1` 的个数

1. 如果正整数 `i` 是一个偶数，那么 `i` 相当于将 `i/2` 左移一位的结果，因此偶数 `i` 和 `i/2` 的二进制表示中 `1` 的个数是相同的。
2. 如果 `i` 是一个奇数，`i` 相当于将 `i/2`左移一位之后再将最右边一位设为 `1` 的结果，因此奇数 `i` 的二进制表示形式中 `1` 的个数比 `i/2` 中 `1` 的个数多 `1`。
比如，整数3的二进制表示为 `11`，有2个1，整数6的二进制表示为`110`，有2个1，整数7的二进制表示为`111`，有3个1。可以根据3的二进制形式中的1的个数直接求出6和7的二进制形式中1的个数。

```java
class Solution {
    public int[] countBits(int n) {
        int[] res = new int[n + 1];
        for(int i = 1; i <= n; i++) {
            // 注意运算优先级，(i & 1)括号不能省略
            res[i] = res[i >> 1] + (i & 1);
        }
        return res;
    }
}
```

代码中使用 `i >> 1` 来计算 `i / 2`，使用 `i & 1` 来计算 `i % 2`，位运算的效率比除法运算和求余运算更高。时间复杂度为 $O(n)$

### 面试题4：只出现一次的数字

```plain
题目：输入一个整数数组，数组中只有一个数字出现了一次，而其他数字都出现了3次。请找出那个只出现一次的数字。例如，如果输入的数组为[0，1，0，1，0，1，100]，则只出现一次的数字是100。
```

分析：这个题目有一个简化版的类似的题目 “输入数组中除一个数字只出现一次之外其他数字都出现两次，请找出只出现一次的数字”。任何一个数字 **异或** 它自己的结果都是 `0`。如果将数组中所有数字进行异或运算，那么最终的结果就是那个只出现一次的数字。

在这个题目中只有一个数字出现了一次，其他数字出现了 $3$ 次。相同的 $3$ 个数字异或的结果是数字本身，但是将数组中所有数字进行异或运算并不能消除出现 $3$ 次的数字。因此，需要想其他办法。

一个整数是由 `32` 个 `0` 或 `1` 组成的。可以将数组中所有数字的 **同一位置** 的数位相加。如果数组中所有数字的第 `i` 个数位相加之和能 **被3整除**，那么只出现一次的数字的第 `i` 个数位一定是 `0`；如果数组中所有数字的第i个数位相加之和 **被3除余1**，那么只出现一次的数字的第 `i` 个数位一定是 `1`。这样只出现一次的任意第 `i` 个数位可以由数组中所有数字的第 `i` 个数位之和推出来。当我们知道一个整数任意一位是 `0` 还是 `1` 之后，就可以知道它的数值。

```java
class Solution {
    public int singleNumber(int[] nums) {
        int[] bitSums = new int[32];
        for(int num : nums) {
            for(int i = 0; i < 32; i++) {
                bitSums[i] += ((num >> (31 - i)) & 1);
            }
        }
        int res = 0;
        for(int i = 0; i < 32; i++) {
            res = (res << 1) + bitSums[i] % 3;
        }
        return res;
    }
}
```

由于 `int` 类型有32位，因此创建一个长度位32的整形数组来存储数组 `nums` 中所有整数二进制形式中第 `i` 个数位之和。`(num >> (31 - i)) & 1` 得到整数 `num` 的二进制形式中第 `i` 个数位。最后根据bitSums将结果拼接起来，如果对应位的值模3不为0，则表示该位的值为1，否则为0。

另一种等价写法：

```java
class Solution {
    public int singleNumber(int[] nums) {
        int[] bitSums = new int[32];
        for(int num : nums) {
            for(int i = 0; i < 32; i++) {
                bitSums[i] += (num >> 31 - i) & 1;
            }
        }

        int res = 0;
        for(int i = 0; i < 32; i++) {
            if(bitSums[i] % 3 != 0) {
                res |= 1 << 31 - i;
            }
        }
        return res;
    }
}
```

扩展：
题目：输入一个整数数组，数组中只有一个数字出现m次，其他数字都出现n次，请找出那个唯一出现m次的数字。假设m不能被n整除。
分析：解决面试题4的方法可以用来解决同类型的问题。如果数组中所有数字的第i个数位相加之和能被n整除，那么出现m次的数字的第i个数位一定是0；否则出现m次的数字的第i个数位一定是1。


### 面试题5：单词长度的最大乘积

```plain
题目：输入一个字符串数组words，请计算不包含相同字符的两个字符串words[i]和words[j]的长度乘积的最大值。如果所有字符串都包含至少一个相同字符，那么返回0。假设字符串中只包含英文小写字母。例如，输入的字符串数组words为["abcw"，"foo"，"bar"，"fxyz"，"abcdef"]，数组中的字符串"bar"与"foo"没有相同的字符，它们长度的乘积为9。"abcw"与"fxyz"也没有相同的字符，它们长度的乘积为16，这是该数组不包含相同字符的一对字符串的长度乘积的最大值。
```

分析：解决这个问题的关键在于如何判断两个字符串str1和str2中没有相同的字符。一个直观的想法是基于字符串str1中的每个字符ch，扫描字符串str2判断字符ch是否出现在str2中。如果两个字符串的长度分别为p和q，那么这种蛮力法的时间复杂度是O（pq）。


思路1：用哈希表记录字符串中出现的字符

对于每个字符串，可以用一个 **哈希表** 记录出现在该字符串中的所有字符。在判断两个字符串`str1` 和 `str2` 中是否有相同的字符时，只需要从 `a` 到 `z` 判断某个字符是否在两个字符串对应的哈希表中都出现了。在哈希表中查找的时间复杂度是 $O(1)$ 。这个题目假设所有字符都是英文小写字母，只有 `26` 个可能的字符，因此最多只需要在每个字符串对应的哈希表中查询 `26` 次就能判断两个字符串是否包含相同的字符。`26` 是一个常数，因此可以认为应用哈希表后判断两个字符串是否包含相同的字符的时间复杂度是 $O(1)$。

由于这个题目只需要考虑26个英文小写字母，因此可以用一个长度为26的布尔型数组来模拟哈希表。数组下标为0的值表示字符'a'是否出现，下标为1的值表示字符'b'是否出现，其余以此类推。

```java
class Solution {
    public int maxProduct(String[] words) {
        boolean[][] flags = new boolean[words.length][26];
        for(int i = 0; i < words.length; i++) {
            for(char c : words[i].toCharArray()) {
                flags[i][c - 'a'] = true;
            }
        }
        int res = 0;
        for(int i = 0; i < words.length; i++) {
            for(int j = i + 1; j < words.length; j++) {
                int k = 0;
                for(; k < 26; k++) {
                    if(flags[i][k] && flags[j][k]) {
                        break;
                    }
                }
                if(k == 26) {
                    int prod = words[i].length() * words[j].length();
                    res = Math.max(res, prod);
                }
            }
        }
        return res;
    }
}
```

1. 初始化每个字符串对应的哈希表。如果数组 `words` 的长度为 `n`，每个字符串的长度为 `k`，那么初始化哈希表的时间复杂度为 $O(nk)$
2. 根据哈希表判断每对字符串是否包含相同的字符，共有 $O(n^2)$ 对字符串，判断每对字符串是否包含相同的字符需要的时间为 $O(1)$，这一步的时间复杂度为 $O(n^2)$，但是常数是 26，整体时间复杂度为 $O(nk + n^2)$

为每个字符串创建一个长度为26的数组用来计算字符串中出现的字符，如果数组words的长度为n，则空间复杂度为 $O(n)$。

思路2：用整数的二进制数位记录字符串中出现的字符

思路1中使用一个长度为 `26` 的布尔型数组记录字符串中出现的字符。布尔值只有两种可能，即 `true` 或 `false`。这与二进制有些类似，在二进制中数字的每个数位要么是 `0` 要么是 `1`。因此，可以将长度为 `26` 的布尔型数组用 `26` 个二进制的 **数位** 代替，二进制的 `0` 对应布尔值 `false`，而 `1` 对应 `true`。

`Java` 中 `int` 型整数的二进制形式有 `32` 位，但只需要 `26` 位就能表示一个字符串中出现的字符，因此可以用一个 `int` 型整数记录某个字符串中出现的字符。如果两个字符串中包含相同的字符，那么它们对应的整数相同的某个数位都为1，两个整数的 **与运算** 将不会等于0。如果两个字符串没有相同的字符，那么它们对应的整数的与运算的结果等于0。

```java
class Solution {
    public int maxProduct(String[] words) {
        int[] flags = new int[words.length];
        for(int i = 0; i < words.length; i++) {
            for(char ch : words[i].toCharArray()) {
                flags[i] |= (1 << (ch - 'a'));
            }
        }

        int res = 0;
        for(int i = 0; i < words.length; i++) {
            for(int j = i + 1; j < words.length; j++) {
                // 位运算与
                if((flags[i] & flags[j]) == 0) {
                    int prod = words[i].length() * words[j].length();
                    res = Math.max(res, prod);
                }
            }
        }
        return res;
    }
}
```

上述代码中的整数 `flags[i]` 用来记录字符串 `words[i]` 中出现的字符。如果 `words[i]` 中出现了某个字符 `ch`，则对应的整数 `flags[i]` 中从右边数起第 `ch-'a'` 个数位将被标记为 `1` 。如果两个整数 `flags[i]` 和 `flags[j]` 的 **与运算** 的结果为 `0`，那么它们对应的字符串 `words[i]` 和 `words[j]` 一定没有相同的字符。此时可以计算它们长度的乘积，并与其他不含相同字符的字符串对的长度乘积相比较，最终得到长度乘积的最大值。如果数组 `words` 的长度为 `n`，平均每个字符串的长度为 `k` ，那么这种解法的时间复杂度是 $O(nk+n^2)$，空间复杂度是 $O(n)$。虽然两种解法的时间复杂度和空间复杂度是同一个量级的，但前面的解法在判断两个字符串是否包含相同的字符时，可能需要26次布尔运算，而新的解法只需要1次位运算，因此新的解法的时间效率更高。

## 1.3 本章小结

本章讨论了最基本的数据类型—— **整数**。编程语言(如Java)可能定义了多种占据不同内存空间的整数类型，内存空间不同的整数类型的值的范围也不相同。整数在计算机中使用二进制形式表示，每位不是 `0` 就是 `1`。位运算是对二进制整数的运算，包括与运算、或运算、非运算、异或运算、左移运算和右移运算。只有深刻理解每种位运算的特点才能在需要的时候灵活地应用合适的位运算解决相应的问题。













